package MelonUtilities.commands.lock;

import MelonUtilities.config.Data;
import MelonUtilities.config.datatypes.PlayerData;
import MelonUtilities.interfaces.BlockEntityContainerInterface;
import MelonUtilities.utility.FeedbackHandler;
import MelonUtilities.utility.MUtil;
import MelonUtilities.utility.SyntaxBuilder;
import MelonUtilities.utility.UUIDHelper;
import net.minecraft.core.HitResult;
import net.minecraft.core.block.entity.*;
import net.minecraft.core.net.command.Command;
import net.minecraft.core.net.command.CommandHandler;
import net.minecraft.core.net.command.CommandSource;
import net.minecraft.core.net.command.TextFormatting;

public class LockCommandOld extends Command {

	private final static String COMMAND = "lock";

	public LockCommandOld() {
		super(COMMAND, "l");
	}

	public static SyntaxBuilder syntax = new SyntaxBuilder();

	public static void buildLockSyntax(){
		syntax.clear();
		syntax.append("title",                                                    TextFormatting.LIGHT_GRAY + "< Command Syntax > ([] = optional, <> = variable, / = or)");
		syntax.append("lock", "title",                                     TextFormatting.LIGHT_GRAY + "  > /lock [<mode>]");
		syntax.append("lockOnBlockPlaced", "lock",                         TextFormatting.LIGHT_GRAY + "    > onBlockPlaced true/false");
		syntax.append("lockOnBlockPunched", "lock",                        TextFormatting.LIGHT_GRAY + "    > onBlockPunched true/false");
		syntax.append("lockTrust", "lock",                                 TextFormatting.LIGHT_GRAY + "    > trust <player>");
		syntax.append("lockTrustAll", "lock",                              TextFormatting.LIGHT_GRAY + "    > trustall <player>");
		syntax.append("lockTrustCommunity", "lock",                        TextFormatting.LIGHT_GRAY + "    > trustcommunity");
		syntax.append("lockUntrust", "lock",                               TextFormatting.LIGHT_GRAY + "    > untrust <player>");
		syntax.append("lockUntrustAll", "lock",                            TextFormatting.LIGHT_GRAY + "    > untrustall <player>");
		syntax.append("lockUntrustCommunity", "lock",                      TextFormatting.LIGHT_GRAY + "    > untrustcommunity");
		syntax.append("lockBypass", "lock", true,                      TextFormatting.LIGHT_GRAY + "    > bypass true/false");
	}

	private boolean onBlockPlaced(CommandHandler handler, CommandSource source, String[] args){
		if(args[1].equals("true")) {
			if(!Data.playerData.getOrCreate(UUIDHelper.getUUIDFromName(source.getSender().username).toString(), PlayerData.class).lockOnBlockPlaced){
				Data.playerData.getOrCreate(UUIDHelper.getUUIDFromName(source.getSender().username).toString(), PlayerData.class).lockOnBlockPlaced = true;
				FeedbackHandler.success(source, "Lock-On-Block-Placed is now On!");
				return true;
			}
			FeedbackHandler.error(source, "Failed to turn Lock-On-Block-Placed On! (Already On)");
			return false;
		}
		if(args[1].equals("false")) {
			if(Data.playerData.getOrCreate(UUIDHelper.getUUIDFromName(source.getSender().username).toString(), PlayerData.class).lockOnBlockPlaced) {
				Data.playerData.getOrCreate(UUIDHelper.getUUIDFromName(source.getSender().username).toString(), PlayerData.class).lockOnBlockPlaced = false;
				FeedbackHandler.success(source, "Lock on Block Placed is now Off!");
				return true;
			}
			FeedbackHandler.error(source, "Failed to turn Lock-On-Block-Placed Off! (Already Off)");
			return false;
		}
		FeedbackHandler.error(source, "Failed to set Lock Mode! (Invalid Syntax)");
		return false;
	}

	private boolean onBlockPunched(CommandHandler handler, CommandSource source, String[] args){
		if(args[1].equals("true")) {
			if(!Data.playerData.getOrCreate(UUIDHelper.getUUIDFromName(source.getSender().username).toString(), PlayerData.class).lockOnBlockPunched){
				Data.playerData.getOrCreate(UUIDHelper.getUUIDFromName(source.getSender().username).toString(), PlayerData.class).lockOnBlockPunched = true;
				FeedbackHandler.success(source, "Lock-On-Block-Punched is now On!");
				return true;
			}
			FeedbackHandler.error(source, "Failed to turn Lock-On-Block-Punched On! (Already On)");
			return true;
		}
		if(args[1].equals("false")) {
			if(Data.playerData.getOrCreate(UUIDHelper.getUUIDFromName(source.getSender().username).toString(), PlayerData.class).lockOnBlockPunched) {
				Data.playerData.getOrCreate(UUIDHelper.getUUIDFromName(source.getSender().username).toString(), PlayerData.class).lockOnBlockPunched = false;
				FeedbackHandler.success(source, "Lock-On-Block-Punched is now Off!");
				return true;
			}
			FeedbackHandler.error(source, "Failed to turn Lock-On-Block-Punched Off! (Already Off)");
			return true;
		}
		FeedbackHandler.error(source, "Failed to set Lock Mode! (Invalid Syntax)");
		return false;
	}

	private boolean trust(CommandHandler handler, CommandSource source, String[] args){
		if(UUIDHelper.getUUIDFromName(args[1]) != null) {

			HitResult rayCastResult = MUtil.rayCastFromPlayer(source);

			if (rayCastResult == null || rayCastResult.hitType != HitResult.HitType.TILE) {
				FeedbackHandler.error(source, "Failed to Trust Player to Container! (Not Looking at Container)");
				return true;
			}

			BlockEntity container = source.getWorld().getBlockEntity(rayCastResult.x, rayCastResult.y, rayCastResult.z);

			if(container != null) {
				if (container instanceof BlockEntityContainerInterface) {
					BlockEntityContainerInterface iContainer = ((BlockEntityContainerInterface) container);
					if (iContainer.getIsLocked()) {

						if (!iContainer.getLockOwner().equals(UUIDHelper.getUUIDFromName(source.getSender().username))) {
							FeedbackHandler.error(source, "Failed to Trust Player to Container! (Not Owned By You)");
							return true;
						}

						if (iContainer.getTrustedPlayers().contains(UUIDHelper.getUUIDFromName(args[1]))) {
							FeedbackHandler.error(source, "Failed to Trust Player to Container! (Player already Trusted)");
							return true;
						}

						if (container instanceof ChestBlockEntity) {
							BlockEntityContainerInterface iOtherContainer = (BlockEntityContainerInterface) MUtil.getOtherChest(source.getWorld(), (ChestBlockEntity) container);
							if (iOtherContainer != null) {
								iContainer.addTrustedPlayer(UUIDHelper.getUUIDFromName(args[1]));
								iOtherContainer.addTrustedPlayer(UUIDHelper.getUUIDFromName(args[1]));
								FeedbackHandler.success(source, "Trusted " + TextFormatting.GRAY + args[1] + TextFormatting.LIME + " to this Double Chest!");
								return true;
							}
							FeedbackHandler.success(source, "Trusted " + TextFormatting.GRAY + args[1] + TextFormatting.LIME + " to this Chest!");
						} else if (container instanceof BlastFurnaceBlockEntity) {
							FeedbackHandler.success(source, "Trusted " + TextFormatting.GRAY + args[1] + TextFormatting.LIME + " to this Blast Furnace!");
						} else if (container instanceof FurnaceBlockEntity) {
							FeedbackHandler.success(source, "Trusted " + TextFormatting.GRAY + args[1] + TextFormatting.LIME + " to this Furnace!");
						} else if (container instanceof DispenserBlockEntity) {
							FeedbackHandler.success(source, "Trusted " + TextFormatting.GRAY + args[1] + TextFormatting.LIME + " to this Dispenser!");
						} else if (container instanceof GoldMeshBlockEntity) {
							FeedbackHandler.success(source, "Trusted " + TextFormatting.GRAY + args[1] + TextFormatting.LIME + " to this Golden Mesh!");
						} else if (container instanceof TrommelBlockEntity) {
							FeedbackHandler.success(source, "Trusted " + TextFormatting.GRAY + args[1] + TextFormatting.LIME + " to this Trommel!");
						} else if (container instanceof BasketBlockEntity) {
							FeedbackHandler.success(source, "Trusted " + TextFormatting.GRAY + args[1] + TextFormatting.LIME + " to this Basket!");
						}
						iContainer.addTrustedPlayer(UUIDHelper.getUUIDFromName(args[1]));
						return true;
					}
				}
			}
			if(container != null) {
				FeedbackHandler.error(source, "Failed to Trust Player to Container! (Container not Locked)");
				return true;
			}
			FeedbackHandler.error(source, "Failed to Trust Player to Container! (Not Looking at Container)");
			return true;
		}
		FeedbackHandler.error(source, "Failed to Trust " + TextFormatting.GRAY + args[1] + TextFormatting.RED + " to Container!");
		FeedbackHandler.error(source, "(Player Doesn't Exist)");
		return true;
	}

	private boolean trustAll(CommandHandler handler, CommandSource source, String[] args){
		if(UUIDHelper.getUUIDFromName(args[1]) != null) {
			if(!Data.playerData.getOrCreate(UUIDHelper.getUUIDFromName(source.getSender().username).toString(), PlayerData.class).playersTrustedToAllContainers.contains(UUIDHelper.getUUIDFromName(args[1]))){
				Data.playerData.loadAll(PlayerData.class);
				Data.playerData.getOrCreate(UUIDHelper.getUUIDFromName(source.getSender().username).toString(), PlayerData.class).playersTrustedToAllContainers.add(UUIDHelper.getUUIDFromName(args[1]));
				Data.playerData.saveAll();
				FeedbackHandler.success(source, "Trusted " + TextFormatting.GRAY + args[1] + TextFormatting.LIME + " to all Containers!");
				return true;
			}
			FeedbackHandler.error(source, "Failed to Trust " + TextFormatting.GRAY + args[1] + TextFormatting.RED + " to all Containers!");
			FeedbackHandler.error(source, "(Player is Already Trusted)");
			return true;
		}
		FeedbackHandler.error(source, "Failed to Trust " + TextFormatting.GRAY + args[1] + TextFormatting.RED + " to all Containers!");
		FeedbackHandler.error(source, "(Player Doesn't Exist)");
		return true;
	}

	private boolean trustCommunity(CommandHandler handler, CommandSource source, String[] args){

		HitResult rayCastResult = MUtil.rayCastFromPlayer(source);

		if (rayCastResult == null || rayCastResult.hitType != HitResult.HitType.TILE) {
			FeedbackHandler.error(source, "Failed to Trust Community to Container! (Not Looking at Container)");
			return true;
		}

		BlockEntity container = source.getWorld().getBlockEntity(rayCastResult.x, rayCastResult.y, rayCastResult.z);

		if (container instanceof BlockEntityContainerInterface) {
			BlockEntityContainerInterface iContainer = ((BlockEntityContainerInterface) container);
			if (iContainer.getIsLocked()) {

				if (!iContainer.getLockOwner().equals(UUIDHelper.getUUIDFromName(source.getSender().username))) {
					FeedbackHandler.error(source, "Failed to Trust Community to Container! (Not Owned By You)");
					return true;
				}

				if (container instanceof ChestBlockEntity) {
					BlockEntityContainerInterface iOtherContainer = (BlockEntityContainerInterface) MUtil.getOtherChest(source.getWorld(), (ChestBlockEntity) container);
					if (iOtherContainer != null) {
						iContainer.setIsCommunityContainer(true);
						iOtherContainer.setIsCommunityContainer(true);
						FeedbackHandler.destructive(source, "Trusted Community to this Double Chest!");
						return true;
					}
					FeedbackHandler.destructive(source, "Trusted Community to this Chest!");
				} else if (container instanceof BlastFurnaceBlockEntity) {
					FeedbackHandler.destructive(source, "Trusted Community to this Blast Furnace!");
				} else if (container instanceof FurnaceBlockEntity) {
					FeedbackHandler.destructive(source, "Trusted Community to this Furnace!");
				} else if (container instanceof DispenserBlockEntity) {
					FeedbackHandler.destructive(source, "Trusted Community to this Dispenser!");
				} else if (container instanceof GoldMeshBlockEntity) {
					FeedbackHandler.destructive(source, "Trusted Community to this Golden Mesh!");
				} else if (container instanceof TrommelBlockEntity) {
					FeedbackHandler.destructive(source, "Trusted Community to this Trommel!");
				} else if (container instanceof BasketBlockEntity) {
					FeedbackHandler.destructive(source, "Trusted Community to this Basket!");
				}
				iContainer.setIsCommunityContainer(true);
				return true;
			}
		}
		if(container != null) {
			FeedbackHandler.error(source, "Failed to Trust Community to Container! (Container not Locked)");
			return true;
		}
		FeedbackHandler.error(source, "Failed to Trust Community to Container! (Not Looking at Container)");
		return true;
	}

	private boolean untrust(CommandHandler handler, CommandSource source, String[] args){
		if(UUIDHelper.getUUIDFromName(args[1]) != null) {

			HitResult rayCastResult = MUtil.rayCastFromPlayer(source);

			if (rayCastResult == null || rayCastResult.hitType != HitResult.HitType.TILE) {
				FeedbackHandler.error(source, "Failed to Untrust Player from Container! (Not Looking at Container)");
				return true;
			}

			BlockEntity container = source.getWorld().getBlockEntity(rayCastResult.x, rayCastResult.y, rayCastResult.z);

			if (container instanceof BlockEntityContainerInterface) {
				BlockEntityContainerInterface iContainer = ((BlockEntityContainerInterface) container);
				if (iContainer.getIsLocked()) {

					if (!iContainer.getLockOwner().equals(UUIDHelper.getUUIDFromName(source.getSender().username))) {
						FeedbackHandler.error(source, "Failed to Untrust Player from Container! (Not Owned By You)");
						return true;
					}

					if (!iContainer.getTrustedPlayers().contains(UUIDHelper.getUUIDFromName(args[1]))) {
						FeedbackHandler.error(source, "Failed to Untrust Player from Container! (Player not Trusted)");
						return true;
					}

					if (container instanceof ChestBlockEntity) {
						BlockEntityContainerInterface iOtherContainer = (BlockEntityContainerInterface) MUtil.getOtherChest(source.getWorld(), (ChestBlockEntity) container);
						if (iOtherContainer != null) {
							iContainer.removeTrustedPlayer(UUIDHelper.getUUIDFromName(args[1]));
							iOtherContainer.removeTrustedPlayer(UUIDHelper.getUUIDFromName(args[1]));
							FeedbackHandler.destructive(source, "Untrusted " + TextFormatting.GRAY + args[1] + TextFormatting.ORANGE + " from this Double Chest!");
							return true;
						}
						FeedbackHandler.destructive(source, "Untrusted " + TextFormatting.GRAY + args[1] + TextFormatting.ORANGE + " from this Chest!");
					} else if (container instanceof BlastFurnaceBlockEntity) {
						FeedbackHandler.destructive(source, "Untrusted " + TextFormatting.GRAY + args[1] + TextFormatting.ORANGE + " from this Blast Furnace!");
					} else if (container instanceof FurnaceBlockEntity) {
						FeedbackHandler.destructive(source, "Untrusted " + TextFormatting.GRAY + args[1] + TextFormatting.ORANGE + " from this Furnace!");
					} else if (container instanceof DispenserBlockEntity) {
						FeedbackHandler.destructive(source, "Untrusted " + TextFormatting.GRAY + args[1] + TextFormatting.ORANGE + " from this Dispenser!");
					} else if (container instanceof GoldMeshBlockEntity) {
						FeedbackHandler.destructive(source, "Untrusted " + TextFormatting.GRAY + args[1] + TextFormatting.ORANGE + " from this Golden Mesh!");
					} else if (container instanceof TrommelBlockEntity) {
						FeedbackHandler.destructive(source, "Untrusted " + TextFormatting.GRAY + args[1] + TextFormatting.ORANGE + " from this Trommel!");
					} else if (container instanceof BasketBlockEntity) {
						FeedbackHandler.destructive(source, "Untrusted " + TextFormatting.GRAY + args[1] + TextFormatting.ORANGE + " from this Basket!");
					}
					iContainer.removeTrustedPlayer(UUIDHelper.getUUIDFromName(args[1]));
					return true;
				}
			}
			if(container != null) {
				FeedbackHandler.error(source, "Failed to Untrust Player from Container! (Container not Locked)");
				return true;
			}
			FeedbackHandler.error(source, "Failed to Untrust Player from Container! (Not Looking at Container)");
			return true;
		}
		FeedbackHandler.error(source, "Failed to Untrust " + TextFormatting.GRAY + args[1] + TextFormatting.RED + " from Container!");
		FeedbackHandler.error(source, "(Player Doesn't Exist)");
		return true;
	}

	private boolean untrustAll(CommandHandler handler, CommandSource source, String[] args){
		if(UUIDHelper.getUUIDFromName(args[1]) != null) {
			if(Data.playerData.getOrCreate(UUIDHelper.getUUIDFromName(source.getSender().username).toString(), PlayerData.class).playersTrustedToAllContainers.contains(UUIDHelper.getUUIDFromName(args[1]))){
				Data.playerData.loadAll(PlayerData.class);
				Data.playerData.getOrCreate(UUIDHelper.getUUIDFromName(source.getSender().username).toString(), PlayerData.class).playersTrustedToAllContainers.remove(UUIDHelper.getUUIDFromName(args[1]));
				Data.playerData.saveAll();
				FeedbackHandler.destructive(source, "Untrusted " + TextFormatting.GRAY + args[1] + TextFormatting.ORANGE + " from all Containers!");
				return true;
			}
			FeedbackHandler.error(source, "Failed to Untrust " + TextFormatting.GRAY + args[1] + TextFormatting.RED + " from all Containers!");
			FeedbackHandler.error(source, "(Player isn't Trusted)");
			return true;
		}
		FeedbackHandler.error(source, "Failed to Untrust " + TextFormatting.GRAY + args[1] + TextFormatting.RED + " from all Containers!");
		FeedbackHandler.error(source, "(Player Doesn't Exist)");
		return true;
	}

	private boolean untrustCommunity(CommandHandler handler, CommandSource source, String[] args){

		HitResult rayCastResult = MUtil.rayCastFromPlayer(source);

		if (rayCastResult == null || rayCastResult.hitType != HitResult.HitType.TILE) {
			FeedbackHandler.error(source, "Failed to Untrust Community from Container! (Not Looking at Container)");
			return true;
		}

		BlockEntity container = source.getWorld().getBlockEntity(rayCastResult.x, rayCastResult.y, rayCastResult.z);

		if(container != null) {
			if (container instanceof BlockEntityContainerInterface) {
				BlockEntityContainerInterface iContainer = ((BlockEntityContainerInterface) container);
				if (iContainer.getIsLocked()) {

					if (!iContainer.getLockOwner().equals(UUIDHelper.getUUIDFromName(source.getSender().username))) {
						FeedbackHandler.error(source, "Failed to Untrust Community from Container! (Not Owned By You)");
						return true;
					}

					if (container instanceof ChestBlockEntity) {
						BlockEntityContainerInterface iOtherContainer = (BlockEntityContainerInterface) MUtil.getOtherChest(source.getWorld(), (ChestBlockEntity) container);
						if (iOtherContainer != null) {
							iContainer.setIsCommunityContainer(false);
							iOtherContainer.setIsCommunityContainer(false);
							FeedbackHandler.destructive(source, "Untrusted Community from this Double Chest!");
							return true;
						}
						FeedbackHandler.destructive(source, "Untrusted Community from this Chest!");
					} else if (container instanceof BlastFurnaceBlockEntity) {
						FeedbackHandler.destructive(source, "Untrusted Community from this Blast Furnace!");
					} else if (container instanceof FurnaceBlockEntity) {
						FeedbackHandler.destructive(source, "Untrusted Community from this Furnace!");
					} else if (container instanceof DispenserBlockEntity) {
						FeedbackHandler.destructive(source, "Untrusted Community from this Dispenser!");
					} else if (container instanceof GoldMeshBlockEntity) {
						FeedbackHandler.destructive(source, "Untrusted Community from this Golden Mesh!");
					} else if (container instanceof TrommelBlockEntity) {
						FeedbackHandler.destructive(source, "Untrusted Community from this Trommel!");
					} else if (container instanceof BasketBlockEntity) {
						FeedbackHandler.destructive(source, "Untrusted Community from this Basket!");
					}
					iContainer.setIsCommunityContainer(false);
					return true;
				}
			}
		}
		FeedbackHandler.error(source, "Failed to Untrust Community from Container! (Not Looking at Container)");
		return true;
	}


	private boolean bypass(CommandHandler handler, CommandSource source, String[] args) {
		if(source.hasAdmin()) {
			if (args[1].equals("true")) {
				if (!Data.playerData.getOrCreate(UUIDHelper.getUUIDFromName(source.getSender().username).toString(), PlayerData.class).lockBypass) {
					Data.playerData.getOrCreate(UUIDHelper.getUUIDFromName(source.getSender().username).toString(), PlayerData.class).lockBypass = true;
					FeedbackHandler.success(source, "Lock-Bypass is now On!");
					return true;
				}
				FeedbackHandler.error(source, "Failed to turn Lock-Bypass On! (Already On)");
				return true;
			}
			if (args[1].equals("false")) {
				if (Data.playerData.getOrCreate(UUIDHelper.getUUIDFromName(source.getSender().username).toString(), PlayerData.class).lockBypass) {
					Data.playerData.getOrCreate(UUIDHelper.getUUIDFromName(source.getSender().username).toString(), PlayerData.class).lockBypass = false;
					FeedbackHandler.success(source, "Lock-Bypass is now Off!");
					return true;
				}
				FeedbackHandler.error(source, "Failed to turn Lock-Bypass Off! (Already Off)");
				return true;
			}
			FeedbackHandler.error(source, "Failed to set Lock-Bypass! (Invalid Syntax)");
			return false;
		}
		FeedbackHandler.error(source, "You don't have permission to use this command!");
		return true;
	}

	@Override
	public boolean execute(CommandHandler handler, CommandSource source, String[] args) {

		if (args.length == 0) {
			HitResult rayCastResult = MUtil.rayCastFromPlayer(source);
			if (rayCastResult == null || rayCastResult.hitType != HitResult.HitType.TILE) {
				FeedbackHandler.error(source, "Failed to Lock Container! (Not Looking at Container)");
				return true;
			}

			BlockEntity container = source.getWorld().getBlockEntity(rayCastResult.x, rayCastResult.y, rayCastResult.z);
			if(container != null){
				if (container instanceof BlockEntityContainerInterface) {
					BlockEntityContainerInterface iContainer = ((BlockEntityContainerInterface) container);
					if (!iContainer.getIsLocked()) {
						if (container instanceof ChestBlockEntity) {
							BlockEntityContainerInterface iOtherContainer = (BlockEntityContainerInterface) MUtil.getOtherChest(source.getWorld(), (ChestBlockEntity) container);
							if (iOtherContainer != null) {
								iContainer.setIsLocked(true);
								iOtherContainer.setIsLocked(true);
								iContainer.setLockOwner(source.getSender().username);
								iOtherContainer.setLockOwner(source.getSender().username);
								FeedbackHandler.success(source, "Locked Double Chest!");
								return true;
							}
							FeedbackHandler.success(source, "Locked Chest!");
						} else if (container instanceof BlastFurnaceBlockEntity) {
							FeedbackHandler.success(source, "Locked Blast Furnace!");
						} else if (container instanceof FurnaceBlockEntity) {
							FeedbackHandler.success(source, "Locked Furnace!");
						} else if (container instanceof DispenserBlockEntity) {
							FeedbackHandler.success(source, "Locked Dispenser!");
						} else if (container instanceof GoldMeshBlockEntity) {
							FeedbackHandler.success(source, "Locked Golden Mesh!");
						} else if (container instanceof TrommelBlockEntity) {
							FeedbackHandler.success(source, "Locked Trommel!");
						} else if (container instanceof BasketBlockEntity) {
							FeedbackHandler.success(source, "Locked Basket!");
						}

						iContainer.setIsLocked(true);
						iContainer.setLockOwner(source.getSender().username);
						return true;

					} else if (iContainer.getIsLocked() && !iContainer.getLockOwner().equals(UUIDHelper.getUUIDFromName(source.getSender().username))) {
						FeedbackHandler.error(source, "Failed to Lock Container! (Not Owned By You)");
						return true;
					}
					FeedbackHandler.error(source, "Failed to Lock Container! (Already Locked)");
					return true;
				}
			}
			FeedbackHandler.error(source, "Failed to Lock Container! (Not Looking at Container)");
			return true;
		}

		switch(args[0]){
			case "onBlockPlaced":
				return onBlockPlaced(handler, source, args);
			case "onBlockPunched":
				return onBlockPunched(handler, source, args);
			case "trust":
				return trust(handler, source, args);
			case "trustall":
				return trustAll(handler, source, args);
			case "trustcommunity":
				return trustCommunity(handler, source, args);
			case "untrust":
				return untrust(handler, source, args);
			case "untrustall":
				return untrustAll(handler, source, args);
			case "untrustcommunity":
				return untrustCommunity(handler, source, args);
			case "bypass":
				return bypass(handler, source, args);
			case "help":
				return false;
		}

		FeedbackHandler.error(source, "Lock Command Failed (Invalid Syntax)");
		syntax.printAllLines(source);
		return true;
	}

	@Override
	public boolean opRequired(String[] strings) {
		return false;
	}

	@Override
	public void sendCommandSyntax(CommandHandler handler, CommandSource source) {
		syntax.printAllLines(source);
	}
}
